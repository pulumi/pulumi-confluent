// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package confluent

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

type KafkaCluster struct {
	pulumi.CustomResourceState

	// LOW(single-zone) or HIGH(multi-zone)
	Availability     pulumi.StringOutput `pulumi:"availability"`
	BootstrapServers pulumi.StringOutput `pulumi:"bootstrapServers"`
	// cku
	Cku pulumi.IntPtrOutput `pulumi:"cku"`
	// Deployment settings. Currently only `sku` is supported.
	Deployment pulumi.StringMapOutput `pulumi:"deployment"`
	// Environment ID
	EnvironmentId pulumi.StringOutput `pulumi:"environmentId"`
	// The name of the cluster
	Name pulumi.StringOutput `pulumi:"name"`
	// Network egress limit(MBps)
	NetworkEgress pulumi.IntPtrOutput `pulumi:"networkEgress"`
	// Network ingress limit(MBps)
	NetworkIngress pulumi.IntPtrOutput `pulumi:"networkIngress"`
	// where
	Region pulumi.StringOutput `pulumi:"region"`
	// AWS / GCP
	ServiceProvider pulumi.StringOutput `pulumi:"serviceProvider"`
	// Storage limit(GB)
	Storage pulumi.IntPtrOutput `pulumi:"storage"`
}

// NewKafkaCluster registers a new resource with the given unique name, arguments, and options.
func NewKafkaCluster(ctx *pulumi.Context,
	name string, args *KafkaClusterArgs, opts ...pulumi.ResourceOption) (*KafkaCluster, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Availability == nil {
		return nil, errors.New("invalid value for required argument 'Availability'")
	}
	if args.EnvironmentId == nil {
		return nil, errors.New("invalid value for required argument 'EnvironmentId'")
	}
	if args.Region == nil {
		return nil, errors.New("invalid value for required argument 'Region'")
	}
	if args.ServiceProvider == nil {
		return nil, errors.New("invalid value for required argument 'ServiceProvider'")
	}
	var resource KafkaCluster
	err := ctx.RegisterResource("confluent:index/kafkaCluster:KafkaCluster", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetKafkaCluster gets an existing KafkaCluster resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetKafkaCluster(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *KafkaClusterState, opts ...pulumi.ResourceOption) (*KafkaCluster, error) {
	var resource KafkaCluster
	err := ctx.ReadResource("confluent:index/kafkaCluster:KafkaCluster", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering KafkaCluster resources.
type kafkaClusterState struct {
	// LOW(single-zone) or HIGH(multi-zone)
	Availability     *string `pulumi:"availability"`
	BootstrapServers *string `pulumi:"bootstrapServers"`
	// cku
	Cku *int `pulumi:"cku"`
	// Deployment settings. Currently only `sku` is supported.
	Deployment map[string]string `pulumi:"deployment"`
	// Environment ID
	EnvironmentId *string `pulumi:"environmentId"`
	// The name of the cluster
	Name *string `pulumi:"name"`
	// Network egress limit(MBps)
	NetworkEgress *int `pulumi:"networkEgress"`
	// Network ingress limit(MBps)
	NetworkIngress *int `pulumi:"networkIngress"`
	// where
	Region *string `pulumi:"region"`
	// AWS / GCP
	ServiceProvider *string `pulumi:"serviceProvider"`
	// Storage limit(GB)
	Storage *int `pulumi:"storage"`
}

type KafkaClusterState struct {
	// LOW(single-zone) or HIGH(multi-zone)
	Availability     pulumi.StringPtrInput
	BootstrapServers pulumi.StringPtrInput
	// cku
	Cku pulumi.IntPtrInput
	// Deployment settings. Currently only `sku` is supported.
	Deployment pulumi.StringMapInput
	// Environment ID
	EnvironmentId pulumi.StringPtrInput
	// The name of the cluster
	Name pulumi.StringPtrInput
	// Network egress limit(MBps)
	NetworkEgress pulumi.IntPtrInput
	// Network ingress limit(MBps)
	NetworkIngress pulumi.IntPtrInput
	// where
	Region pulumi.StringPtrInput
	// AWS / GCP
	ServiceProvider pulumi.StringPtrInput
	// Storage limit(GB)
	Storage pulumi.IntPtrInput
}

func (KafkaClusterState) ElementType() reflect.Type {
	return reflect.TypeOf((*kafkaClusterState)(nil)).Elem()
}

type kafkaClusterArgs struct {
	// LOW(single-zone) or HIGH(multi-zone)
	Availability string `pulumi:"availability"`
	// cku
	Cku *int `pulumi:"cku"`
	// Deployment settings. Currently only `sku` is supported.
	Deployment map[string]string `pulumi:"deployment"`
	// Environment ID
	EnvironmentId string `pulumi:"environmentId"`
	// The name of the cluster
	Name *string `pulumi:"name"`
	// Network egress limit(MBps)
	NetworkEgress *int `pulumi:"networkEgress"`
	// Network ingress limit(MBps)
	NetworkIngress *int `pulumi:"networkIngress"`
	// where
	Region string `pulumi:"region"`
	// AWS / GCP
	ServiceProvider string `pulumi:"serviceProvider"`
	// Storage limit(GB)
	Storage *int `pulumi:"storage"`
}

// The set of arguments for constructing a KafkaCluster resource.
type KafkaClusterArgs struct {
	// LOW(single-zone) or HIGH(multi-zone)
	Availability pulumi.StringInput
	// cku
	Cku pulumi.IntPtrInput
	// Deployment settings. Currently only `sku` is supported.
	Deployment pulumi.StringMapInput
	// Environment ID
	EnvironmentId pulumi.StringInput
	// The name of the cluster
	Name pulumi.StringPtrInput
	// Network egress limit(MBps)
	NetworkEgress pulumi.IntPtrInput
	// Network ingress limit(MBps)
	NetworkIngress pulumi.IntPtrInput
	// where
	Region pulumi.StringInput
	// AWS / GCP
	ServiceProvider pulumi.StringInput
	// Storage limit(GB)
	Storage pulumi.IntPtrInput
}

func (KafkaClusterArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*kafkaClusterArgs)(nil)).Elem()
}

type KafkaClusterInput interface {
	pulumi.Input

	ToKafkaClusterOutput() KafkaClusterOutput
	ToKafkaClusterOutputWithContext(ctx context.Context) KafkaClusterOutput
}

func (*KafkaCluster) ElementType() reflect.Type {
	return reflect.TypeOf((**KafkaCluster)(nil)).Elem()
}

func (i *KafkaCluster) ToKafkaClusterOutput() KafkaClusterOutput {
	return i.ToKafkaClusterOutputWithContext(context.Background())
}

func (i *KafkaCluster) ToKafkaClusterOutputWithContext(ctx context.Context) KafkaClusterOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KafkaClusterOutput)
}

// KafkaClusterArrayInput is an input type that accepts KafkaClusterArray and KafkaClusterArrayOutput values.
// You can construct a concrete instance of `KafkaClusterArrayInput` via:
//
//	KafkaClusterArray{ KafkaClusterArgs{...} }
type KafkaClusterArrayInput interface {
	pulumi.Input

	ToKafkaClusterArrayOutput() KafkaClusterArrayOutput
	ToKafkaClusterArrayOutputWithContext(context.Context) KafkaClusterArrayOutput
}

type KafkaClusterArray []KafkaClusterInput

func (KafkaClusterArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*KafkaCluster)(nil)).Elem()
}

func (i KafkaClusterArray) ToKafkaClusterArrayOutput() KafkaClusterArrayOutput {
	return i.ToKafkaClusterArrayOutputWithContext(context.Background())
}

func (i KafkaClusterArray) ToKafkaClusterArrayOutputWithContext(ctx context.Context) KafkaClusterArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KafkaClusterArrayOutput)
}

// KafkaClusterMapInput is an input type that accepts KafkaClusterMap and KafkaClusterMapOutput values.
// You can construct a concrete instance of `KafkaClusterMapInput` via:
//
//	KafkaClusterMap{ "key": KafkaClusterArgs{...} }
type KafkaClusterMapInput interface {
	pulumi.Input

	ToKafkaClusterMapOutput() KafkaClusterMapOutput
	ToKafkaClusterMapOutputWithContext(context.Context) KafkaClusterMapOutput
}

type KafkaClusterMap map[string]KafkaClusterInput

func (KafkaClusterMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*KafkaCluster)(nil)).Elem()
}

func (i KafkaClusterMap) ToKafkaClusterMapOutput() KafkaClusterMapOutput {
	return i.ToKafkaClusterMapOutputWithContext(context.Background())
}

func (i KafkaClusterMap) ToKafkaClusterMapOutputWithContext(ctx context.Context) KafkaClusterMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(KafkaClusterMapOutput)
}

type KafkaClusterOutput struct{ *pulumi.OutputState }

func (KafkaClusterOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**KafkaCluster)(nil)).Elem()
}

func (o KafkaClusterOutput) ToKafkaClusterOutput() KafkaClusterOutput {
	return o
}

func (o KafkaClusterOutput) ToKafkaClusterOutputWithContext(ctx context.Context) KafkaClusterOutput {
	return o
}

type KafkaClusterArrayOutput struct{ *pulumi.OutputState }

func (KafkaClusterArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*KafkaCluster)(nil)).Elem()
}

func (o KafkaClusterArrayOutput) ToKafkaClusterArrayOutput() KafkaClusterArrayOutput {
	return o
}

func (o KafkaClusterArrayOutput) ToKafkaClusterArrayOutputWithContext(ctx context.Context) KafkaClusterArrayOutput {
	return o
}

func (o KafkaClusterArrayOutput) Index(i pulumi.IntInput) KafkaClusterOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *KafkaCluster {
		return vs[0].([]*KafkaCluster)[vs[1].(int)]
	}).(KafkaClusterOutput)
}

type KafkaClusterMapOutput struct{ *pulumi.OutputState }

func (KafkaClusterMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*KafkaCluster)(nil)).Elem()
}

func (o KafkaClusterMapOutput) ToKafkaClusterMapOutput() KafkaClusterMapOutput {
	return o
}

func (o KafkaClusterMapOutput) ToKafkaClusterMapOutputWithContext(ctx context.Context) KafkaClusterMapOutput {
	return o
}

func (o KafkaClusterMapOutput) MapIndex(k pulumi.StringInput) KafkaClusterOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *KafkaCluster {
		return vs[0].(map[string]*KafkaCluster)[vs[1].(string)]
	}).(KafkaClusterOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*KafkaClusterInput)(nil)).Elem(), &KafkaCluster{})
	pulumi.RegisterInputType(reflect.TypeOf((*KafkaClusterArrayInput)(nil)).Elem(), KafkaClusterArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*KafkaClusterMapInput)(nil)).Elem(), KafkaClusterMap{})
	pulumi.RegisterOutputType(KafkaClusterOutput{})
	pulumi.RegisterOutputType(KafkaClusterArrayOutput{})
	pulumi.RegisterOutputType(KafkaClusterMapOutput{})
}
